---
title: "Low-Volatility Cycles Analysis - Example Walkthrough"
author: "Advanced Investment Strategies LVC "
date: '`r Sys.Date()`'
output:
  pdf_document:
    toc: true
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Introduction

This notebook demonstrates the complete workflow for replicating the Garcia-Feijóo et al. (2015) paper on Low-Volatility Cycles.

## Paper Summary

**Title:** Low-Volatility Cycles: The Influence of Valuation and Momentum on Low-Volatility Portfolios

**Main Finding:** The low-volatility anomaly is driven by cyclical variations in book-to-price ratios and momentum effects.

# Setup

## Load Packages

```{r load-packages}

# List of required packages
packages <- c(
  # Workflow and pipeline
  "targets",
  
  # Data wrangling and visualization
  "tidyverse",
  "lubridate",
  "zoo",
  "broom",
  "ggplot2",
  "knitr",
  
  # Database access and I/O
  "DBI",
  "RSQLite",
  "dbplyr",
  "readr"
)

# Install any missing packages
installed <- packages %in% rownames(installed.packages())
if (any(!installed)) {
  install.packages(packages[!installed])
}

# Load all required packages
lapply(packages, library, character.only = TRUE)

# Source all custom functions (used by {targets})
tar_source()

```

## Configuration

```{r config}
# Analysis parameters
N_PORTFOLIOS <- 5
BETA_WINDOW <- 60
MIN_OBS <- 24
```

# Data Loading and Cleaning

## Load Raw Data

```{r load-data}
# Load CRSP data
crsp_raw <- load_crsp_data("data/crsp_monthly.csv")

# Load Compustat data
compustat_raw <- load_compustat_data("data/compustat_annual.csv")

# Load market returns
market_returns <- load_market_returns("data/market_returns.csv")

# Load Fama-French factors
ff_factors <- load_ff_factors("data/ff_factors.csv")
```

## Clean and Merge Data

```{r clean-data}
# Clean CRSP
crsp_clean <- clean_crsp_data(crsp_raw)

# --- Price screen (abs(prc) in [2, 1000]) + NYSE large-cap breakpoint (monthly) ---
crsp_sz <- crsp_clean %>%
  # price screen (CRSP uses negative sign convention → use abs)
  filter(!is.na(prc), abs(prc) >= 2, abs(prc) <= 1000) %>%
  mutate(
    mktcap = abs(prc) * shrout * 1000  # USD
  ) %>%
  # guards
  filter(!is.na(mktcap), mktcap > 0, !is.na(exchcd), !is.na(date), !is.na(permno))

# NYSE 67th-percentile size cutoff per month
nyse_cut <- crsp_sz %>%
  filter(exchcd == 1L) %>%
  group_by(date) %>%
  summarize(cut67 = quantile(mktcap, probs = 2/3, na.rm = TRUE), .groups = "drop")

# Keep large-cap universe (apply NYSE cutoff to all exchanges)
crsp_largecap <- crsp_sz %>%
  inner_join(nyse_cut, by = "date") %>%
  filter(mktcap >= cut67)

# Clean Compustat
compustat_clean <- clean_compustat_data(compustat_raw)

# Make Compustat unique at (permno, year)
compustat_unique <- compustat_clean %>%
  dplyr::mutate(year = if (!"year" %in% names(.)) lubridate::year(datadate) else year) %>%
  dplyr::arrange(permno, year, dplyr::desc(datadate), dplyr::desc(at), dplyr::desc(be)) %>%
  dplyr::group_by(permno, year) %>%
  dplyr::slice_head(n = 1) %>%
  dplyr::ungroup() %>%
  dplyr::select(permno, datadate, year, be_usd, at_usd)  # << keep *_usd


# Merge datasets
merged_data <- merge_crsp_compustat(crsp_largecap, compustat_unique)

# Preview
head(merged_data) %>% kable()

```

# Portfolio Formation

## Calculate Rolling Betas (with parallel computation)

```{r calc-betas-parallel, message=FALSE, warning=FALSE}
# Packages
req_pkgs <- c("future", "future.apply")
new <- req_pkgs[!req_pkgs %in% rownames(installed.packages())]
if (length(new)) install.packages(new, quiet = TRUE)
lapply(req_pkgs, library, character.only = TRUE)

# --- Detect and cap cores ---
n_cores_total <- parallel::detectCores(logical = TRUE)
n_cores <- min( max(1, n_cores_total - 1), 32 )  # cap at 32 workers to avoid connection overflow

cat("Detected", n_cores_total, "cores → using", n_cores, "workers\n")

# Optional: limit BLAS threads per worker
if ("data.table" %in% .packages()) data.table::setDTthreads(1)
if ("RhpcBLASctl" %in% rownames(installed.packages())) {
  library(RhpcBLASctl)
  blas_set_num_threads(1)
  omp_set_num_threads(1)
}

# Set up plan
plan(multisession, workers = n_cores)

# Split data by stock
id_col <- "permno"
stopifnot(id_col %in% names(merged_data))
by_stock <- split(merged_data, merged_data[[id_col]], drop = TRUE)

# Compute rolling betas in parallel
beta_list <- future.apply::future_lapply(
  by_stock,
  function(df) calculate_rolling_betas(df, market_returns, window = BETA_WINDOW),
  future.seed = TRUE
)

stock_betas <- dplyr::bind_rows(beta_list)

plan(sequential)  # restore default

summary(stock_betas$beta) |>
  tibble::enframe(name = "stat", value = "beta") |>
  knitr::kable()

```

## Form Beta-Sorted Portfolios

```{r form-portfolios}
# Keep valid betas
betas_ok <- stock_betas %>%
  dplyr::filter(!is.na(beta))

# Assign stocks to portfolios by within-month beta quantiles
beta_portfolios <- betas_ok %>%
  dplyr::group_by(date) %>%
  dplyr::mutate(portfolio = dplyr::ntile(beta, N_PORTFOLIOS)) %>%
  dplyr::ungroup()

# Portfolio distribution check
table(beta_portfolios$portfolio) %>% knitr::kable()

# --- Basic distribution checks ------------------------------------------------
cat("\nNumber of stocks per beta portfolio:\n")
table(beta_portfolios$portfolio)

cat("\nSample dates range:\n")
range(beta_portfolios$date)

cat("\nObservations per month (should be stable over time):\n")
beta_portfolios %>%
  dplyr::count(date) %>%
  summary(n)

# --- Average beta by portfolio ------------------------------------------------
beta_summary <- beta_portfolios %>%
  dplyr::group_by(portfolio) %>%
  dplyr::summarise(
    n_obs = dplyr::n(),
    mean_beta = mean(beta, na.rm = TRUE),
    sd_beta   = sd(beta, na.rm = TRUE),
    min_beta  = min(beta, na.rm = TRUE),
    max_beta  = max(beta, na.rm = TRUE),
    .groups = "drop"
  )

knitr::kable(beta_summary, caption = "Average Beta by Portfolio")

# --- Merge with CRSP large-cap data to inspect market cap & returns -----------
beta_panel <- beta_portfolios %>%
  dplyr::select(permno, date, portfolio) %>%
  dplyr::inner_join(
    crsp_largecap %>% dplyr::select(permno, date, ret, mktcap),
    by = c("permno", "date")
  )

# 3) Average market cap and mean raw return per portfolio
capret_summary <- beta_panel %>%
  dplyr::group_by(portfolio) %>%
  dplyr::summarise(
    avg_mktcap_mil = mean(mktcap / 1e6, na.rm = TRUE),   # in billions
    mean_ret = mean(ret, na.rm = TRUE),
    sd_ret   = sd(ret, na.rm = TRUE),
    n_obs    = dplyr::n(),
    .groups  = "drop"
  )

knitr::kable(capret_summary, caption = "Average Market Cap and Return by Portfolio")

# --- Optional: Time-series consistency check ---------------------------------
portfolio_counts <- beta_portfolios %>%
  dplyr::group_by(date, portfolio) %>%
  dplyr::summarise(n = dplyr::n(), .groups = "drop")

ggplot2::ggplot(portfolio_counts,
                ggplot2::aes(x = date, y = n, color = as.factor(portfolio))) +
  ggplot2::geom_line(alpha = 0.7) +
  ggplot2::labs(title = "Stock Count per Beta Portfolio over Time",
                x = NULL, y = "Count",
                color = "Portfolio") +
  ggplot2::theme_minimal()


```

# Portfolio Analysis

## Book-to-Price Spreads

```{r bp-spreads}
# Calculate B/P spreads

# join portfolios to accounting+CRSP panel to get bp and mktcap
beta_panel <- beta_portfolios %>%
  dplyr::select(permno, date, portfolio) %>%
  dplyr::inner_join(
    merged_data %>% dplyr::select(permno, date, bp, mktcap, ret),
    by = c("permno","date")
  ) %>%
  dplyr::arrange(permno, date) %>%
  dplyr::group_by(permno) %>%
  dplyr::mutate(w_lag = dplyr::lag(mktcap)) %>%
  dplyr::ungroup()



bp_spreads <- calculate_bp_spreads(beta_portfolios)

# Plot B/P spreads over time
bp_spreads %>%
  filter(portfolio %in% c(1, 10)) %>%
  ggplot(aes(x = date, y = bp_vw, color = as.factor(portfolio))) +
  geom_line() +
  labs(
    title = "Book-to-Price Ratios: Low vs High Beta",
    x = "Date",
    y = "B/P Ratio (Value-Weighted)",
    color = "Portfolio"
  ) +
  theme_minimal()
```

## Portfolio Returns

```{r portfolio-returns}
# Calculate returns
portfolio_returns <- calculate_portfolio_returns(beta_portfolios)

# Summary by portfolio
portfolio_returns %>%
  group_by(portfolio) %>%
  summarise(
    mean_ret_ew = mean(ret_ew, na.rm = TRUE) * 12 * 100,
    sd_ret_ew = sd(ret_ew, na.rm = TRUE) * sqrt(12) * 100,
    sharpe_ew = mean_ret_ew / sd_ret_ew
  ) %>%
  kable(digits = 2)
```

# Regression Analysis

## CAPM Regressions

```{r capm}
# Run CAPM regressions
capm_results <- run_capm_regressions(portfolio_returns, market_returns)

# Display results
capm_results %>%
  select(portfolio, alpha_ew, alpha_t_ew, beta_ew, r2_ew) %>%
  kable(digits = 3)
```

## Fama-French 4-Factor

```{r ff4}
# Run FF4 regressions
ff4_results <- run_ff4_regressions(portfolio_returns, ff_factors)

# Display results
ff4_results %>%
  select(portfolio, alpha_ew, alpha_t_ew, beta_mkt_ew, 
         beta_smb_ew, beta_hml_ew, beta_umd_ew) %>%
  kable(digits = 3)
```

# Results Visualization

## Alpha Comparison

```{r alpha-plot}
# Compare CAPM and FF4 alphas
alpha_comparison <- capm_results %>%
  select(portfolio, capm_alpha = alpha_ew) %>%
  left_join(
    ff4_results %>% select(portfolio, ff4_alpha = alpha_ew),
    by = "portfolio"
  ) %>%
  filter(portfolio != 0) %>%
  pivot_longer(cols = c(capm_alpha, ff4_alpha), 
               names_to = "model", 
               values_to = "alpha")

ggplot(alpha_comparison, aes(x = portfolio, y = alpha * 100, fill = model)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    title = "Monthly Alphas by Portfolio",
    x = "Beta Portfolio (1=Low, 10=High)",
    y = "Alpha (% per month)",
    fill = "Model"
  ) +
  theme_minimal()
```

## Cumulative Returns

```{r cumulative-returns}
# Calculate and plot cumulative returns
portfolio_returns %>%
  filter(portfolio %in% c(1, 10)) %>%
  group_by(portfolio) %>%
  arrange(date) %>%
  mutate(cum_ret = cumprod(1 + ret_vw) - 1) %>%
  ggplot(aes(x = date, y = cum_ret * 100, color = as.factor(portfolio))) +
  geom_line() +
  labs(
    title = "Cumulative Returns: Low vs High Beta",
    x = "Date",
    y = "Cumulative Return (%)",
    color = "Portfolio"
  ) +
  theme_minimal()
```

# Using Targets Workflow

Instead of running code chunks individually, use the targets pipeline:

```{r targets-workflow, eval=FALSE}
# Visualize pipeline
tar_visnetwork()

# Run full pipeline
tar_make()

# Load specific results
tar_load(table3)
tar_load(capm_results)

# View loaded data
print(table3)
```

# Interpreting Results

## Key Findings

1. **Low-Beta Anomaly**: Portfolio 1 (low beta) tends to outperform Portfolio 10 (high beta)

2. **Book-to-Price Effect**: Low-beta stocks often have higher B/P ratios

3. **Alpha Patterns**: After controlling for FF4 factors, alphas may diminish

## Robustness Checks

Consider testing:
- Different portfolio formation frequencies
- Alternative beta estimation windows
- Subperiod analysis
- Size and liquidity filters

# Conclusion

This analysis replicates the key findings of Garcia-Feijóo et al. (2015), showing how valuation and momentum influence low-volatility portfolio returns.

# References

Garcia-Feijóo, L., Kochard, L., Sullivan, R. N., & Wang, P. (2015). Low-Volatility Cycles: The Influence of Valuation and Momentum on Low-Volatility Portfolios. *Financial Analysts Journal*, 71(3), 47-60.

---

# Session Info

```{r session-info}
sessionInfo()
```
